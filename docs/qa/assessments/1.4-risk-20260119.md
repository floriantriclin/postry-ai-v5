# Risk Assessment : Story 1.4 - ICE Core Logic

**Date:** 2026-01-19
**Scope:** `lib/ice-logic.ts`, `lib/ice-constants.ts`
**Story:** [Story 1.4 : Logique socle du Protocole ICE](docs/stories/story-1-4-ice-core-logic.md)

## 1. Context & Criticality
This story implements the **core algorithm** of the ICE Protocol. It is a pure logic layer with no UI or API dependencies, but it is the "brain" of the application.
*   **Criticality:** **HIGH**. Any error here results in incorrect user profiling, invalidating the product's value proposition.
*   **Complexity:** **MEDIUM**. The math is simple, but the business rules (tie-breaking, selection priorities) are specific and strict.

## 2. Identified Risks

### 2.1 Algorithmic Precision (Calculation Errors)
*   **Risk:** The formula `Vnew = Vold + (Target - Vold) * 0.3` involves floating point calculations.
*   **Detail:** The spec requires rounding to the nearest integer (e.g., 59.5 -> 60). JavaScript's `Math.round` handles this, but cumulative errors or incorrect implementation (floor vs round) could lead to off-by-one errors.
*   **Impact:** Vectors drift slightly from expected values, potentially changing the "Label Final" or "Definition" in edge cases.

### 2.2 Rule Implementation Fidelity
*   **Risk:** Misinterpretation of the "Tie-Breaking" rules in Phase 2 dimension selection.
*   **Detail:** The rule "If equality, select dimensions based on Phase 1 order" relies on `PHASE_1_ORDER` being strictly defined and correctly iterated.
*   **Impact:** Wrong dimensions selected for Phase 2 questions, leading to a sub-optimal profiling experience.

### 2.3 Hamming Distance Ambiguity
*   **Risk:** Multiple archetypes having the same distance from the user's signature.
*   **Detail:** The spec says "En cas d'égalité, le premier trouvé est retourné". This makes the **order** of archetypes in `lib/ice-constants.ts` functionally significant.
*   **Impact:** Implicit dependency on array order. If the constants are reordered, the fallback archetype changes.

### 2.4 Data Integrity
*   **Risk:** Discrepancy between `docs/specs/ice_protocol.md` and `lib/ice-constants.ts`.
*   **Detail:** The spec defines 15 archetypes with specific binary signatures and base vectors. A typo in a single bit or value breaks the detection logic. Note: ID 11 is missing in the sequence (1-10, 12-16), which must be respected.
*   **Impact:** Impossible to detect certain archetypes or incorrect base vector initialization.

## 3. Mitigation Strategies

### 3.1 Strict Unit Testing (Vitest)
*   **Strategy:** Implement a comprehensive suite of unit tests in `lib/ice-protocol.spec.ts`.
*   **Focus:**
    *   **Exactitude:** Use the "Example Concret" from `ice_protocol.md` (Section 3.2) as a test case to verify `updateVector`.
    *   **Boundaries:** Test `updateVector` at 0 and 100 to ensure no overflow/underflow.
    *   **Tie-Breaking:** Create synthetic test cases where multiple dimensions have exactly the same score (e.g., 40) to verify `getTargetDimensions` respects the Phase 1 priority order.
    *   **Hamming:** Test signature matching with 0, 1, and 2 bits of difference.

### 3.2 Type Safety & Validation
*   **Strategy:** Use Zod schemas and TypeScript interfaces.
*   **Detail:**
    *   `Vstyle` must be a tuple of 9 numbers (0-100).
    *   `BinarySignature` must be a regex-validated string `^[01]{6}$`.
    *   `Archetype` object structure must be enforced.

### 3.3 Constant Freezing
*   **Strategy:** Ensure `lib/ice-constants.ts` uses `as const` and is treated as a single source of truth.
*   **Detail:** Verify the Archetype list order matches the spec's implicit priority if relevant (though spec implies "first found", stability is key).

## 4. Test Recommendations
*   **T1.4.1 (Unit):** Verify `getClosestArchetype` returns exact match for all 15 defined binary signatures.
*   **T1.4.2 (Unit):** Verify `getClosestArchetype` correctly handles a 1-bit difference (distance = 1) and returns the expected fallback.
*   **T1.4.3 (Unit):** Verify `updateVector` calculation: `85 + (0 - 85)*0.3 = 59.5 -> 60`.
*   **T1.4.4 (Unit):** Verify `getTargetDimensions` logic:
    *   Always includes STR, INF, ANC (if not already tested, but Phase 1 tests specific 6). *Correction:* Phase 1 tests POS, TEM, DEN, PRI, CAD, REG. So STR, INF, ANC are *always* the untested ones in Phase 2?
    *   *Check Spec:* "Priorité 1 : Les 3 non-testées en Phase 1 (STR, INF, ANC)." Yes, they are always included.
    *   *Check Spec:* "Priorité 2 : Les 2 dont la valeur... est la plus proche de 50."
    *   Test this selection logic with a mocked vector.
