# Analyse de Risques & Stratégie de Test pour la Story 1.8.2

## 1. Analyse des Risques

| ID | Risque | Cause Potentielle | Impact (1-5) | Probabilité (1-5) | Criticité (I*P) | Stratégie de Mitigation |
|---|---|---|---|---|---|---|
| **R1** | **Race Condition entre `/refine` et `/profile`** | L'appel à `/profile` pourrait être traité par le backend avant la complétion de tous les appels `/refine` asynchrones, menant à un profil basé sur des données incomplètes. | 5 (Très Élevé) | 3 (Moyenne) | 15 | Tests d'intégration backend simulant des latences variables sur `/refine` pour s'assurer que `/profile` attend ou consolide correctement les données. Monitoring et logging des temps de traitement. |
| **R2** | **Décalage entre l'UI et le profil réel** | La nature "fire-and-forget" de `/refine` fait que l'UI avance immédiatement. Si un appel `/refine` échoue en silence, l'état côté serveur est désynchronisé de ce que l'utilisateur a soumis, corrompant le profil final. | 4 (Élevé) | 3 (Moyenne) | 12 | Implémenter une gestion d'erreur robuste côté client pour les appels `/refine` (ex: retry discret, logging d'erreur). Ajouter un test E2E qui simule un échec réseau sur un appel `/refine` et vérifie le comportement. |
| **R3** | **Performance Perçue Dégradée** | Si l'appel de prefetching à `/generate?phase=2` est lent ou échoue, l'utilisateur subit une attente imprévue et potentiellement longue au moment de passer à la phase 2, annulant le bénéfice du pré-chargement. | 3 (Modéré) | 4 (Haute) | 12 | Mettre en place des tests de performance sur l'endpoint `/generate`. Simuler une réponse lente de l'API en E2E pour valider que l'indicateur de chargement (AC 1.3) s'affiche correctement et n'est pas bloquant. |
| **R4** | **Perte de Cohérence des Données** | Si l'utilisateur quitte et reprend le quiz, ou si un appel `/refine` échoue, l'état du profil peut devenir incohérent. Le backend doit pouvoir gérer des requêtes `/refine` désordonnées ou dupliquées. | 4 (Élevé) | 2 (Faible) | 8 | Le backend doit utiliser un mécanisme (ex: `quizId`) pour garantir l'idempotence et l'ordre des mises à jour du profil. Tests unitaires backend spécifiques pour ce cas. |

## 2. Plan de Test

### A. Tests d'Intégration (API - `vitest`)

Ces tests valident la logique métier et les interactions entre les endpoints sans dépendre de l'UI.

1.  **`test('Flux complet nominal Phase 2')`**
    *   **Scénario :** Simule le parcours complet de la phase 2.
    *   **Étapes :**
        1.  Appeler `POST /api/quiz/generate?phase=2` pour obtenir les questions 7-11.
        2.  Pour chaque question (7 à 10), appeler `POST /api/quiz/refine` avec une réponse.
        3.  Après la 11ème réponse, appeler `POST /api/quiz/refine`.
        4.  Appeler `POST /api/quiz/profile`.
    *   **Assertions :**
        *   Vérifier que la réponse de `/profile` contient `label_final` et `definition_longue`.
        *   Vérifier que le statut de la réponse est 200 OK.
        *   Optionnel : Valider le schéma de la réponse avec Zod.

2.  **`test('Gestion de latence /profile après /refine')`**
    *   **Scénario :** Simule un traitement lent du dernier appel `/refine` pour tester la robustesse de `/profile`.
    *   **Étapes :**
        1.  Simuler l'ensemble des appels `/refine`.
        2.  Introduire un délai artificiel *avant* de résoudre la promesse du dernier appel `/refine`.
        3.  Appeler `/profile` immédiatement après avoir envoyé la requête `/refine` (sans attendre sa résolution).
    *   **Assertions :**
        *   S'assurer que `/profile` retourne bien le profil final et complet, prouvant qu'il a attendu la fin du traitement de `/refine`.

### B. Tests End-to-End (E2E - `playwright`)

Ces tests simulent le parcours utilisateur complet dans un navigateur.

1.  **`test('Parcours utilisateur complet - Phase 2 heureuse')`**
    *   **Scénario :** Valide l'expérience utilisateur nominale de la phase 2.
    *   **Étapes :**
        1.  Terminer la phase 1 du quiz pour arriver à l'interstitiel.
        2.  **Intercepter** et **vérifier** que l'appel `POST /api/quiz/generate?phase=2` est bien lancé à l'affichage de l'interstitiel.
        3.  Cliquer pour démarrer la phase 2.
        4.  Répondre aux questions 7 à 11.
        5.  **Intercepter** et **vérifier** que chaque réponse déclenche un appel `POST /api/quiz/refine`.
        6.  Après la 11ème réponse, **vérifier** l'affichage de l'écran de chargement du profil.
        7.  **Intercepter** et **vérifier** l'appel `POST /api/quiz/profile`.
        8.  Attendre l'affichage du résultat final.
    *   **Assertions :**
        *   La barre de progression "Précision" passe de 50% à 100%.
        *   Le `label_final` est correctement affiché.

2.  **`test('Gestion de prefetching lent')`**
    *   **Scénario :** Valide l'affichage du loader si la phase 2 n'est pas prête.
    *   **Étapes :**
        1.  Arriver à l'interstitiel de la phase 1.
        2.  **Intercepter** l'appel `/generate?phase=2` et y introduire un délai de réponse artificiel (ex: 3 secondes).
        3.  Cliquer immédiatement sur le bouton pour commencer la phase 2.
    *   **Assertions :**
        *   Un indicateur de chargement est visible (AC 1.3).
        *   Une fois la réponse de l'API reçue, l'indicateur disparaît et la question 7 s'affiche.

3.  **`test('Gestion d\'échec silencieux de /refine')`**
    *   **Scénario :** Valide la résilience de l'UI face à un échec réseau sur un appel de raffinement.
    *   **Étapes :**
        1.  Commencer la phase 2.
        2.  **Intercepter** et **faire échouer** (erreur 500) l'appel `/refine` pour la question 8.
    *   **Assertions :**
        *   L'UI doit passer sans heurt à la question 9, sans bloquer l'utilisateur (AC 1.2).
        *   Le profil final généré sera potentiellement impacté, ce qui est le comportement attendu du "fire-and-forget", mais l'expérience utilisateur reste fluide.
