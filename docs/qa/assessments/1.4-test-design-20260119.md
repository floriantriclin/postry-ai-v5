# Test Design : Story 1.4 - ICE Core Logic

**Date:** 2026-01-19
**Scope:** `lib/ice-logic.ts`
**Story:** [Story 1.4 : Logique socle du Protocole ICE](docs/stories/story-1-4-ice-core-logic.md)
**Related Risk Assessment:** [1.4-risk-20260119.md](docs/qa/assessments/1.4-risk-20260119.md)

## 1. Strategy Overview
*   **Level:** Unit Testing (Vitest).
*   **Focus:** Algorithmic correctness, boundary analysis, and strict adherence to the ICE Protocol specification.
*   **Tools:** Vitest, Zod (for schema validation testing).

## 2. Test Cases

### Suite 1: Data Integrity & Constants
*   **TC-1.4.1:** **Archetype Registry Integrity**
    *   *Input:* `ICE_ARCHETYPES` constant.
    *   *Assertion:* Object contains exactly 15 keys.
    *   *Assertion:* Each archetype has a valid 6-bit binary signature.
    *   *Assertion:* Each archetype has a valid 9-value base vector (values 0-100).

### Suite 2: Archetype Detection (`getClosestArchetype`)
*   **TC-1.4.2:** **Exact Match Detection**
    *   *Input:* Signature "101100" (Strategist).
    *   *Expected Output:* `ICE_ARCHETYPES.STRATEGIST`.
    *   *Coverage:* Test for at least one archetype per family.

*   **TC-1.4.3:** **Approximate Match (Distance = 1)**
    *   *Input:* Signature "101101" (Strategist is 101100).
    *   *Expected Output:* `ICE_ARCHETYPES.STRATEGIST` (assuming it's the closest).
    *   *Logic:* Verify Hamming distance calculation picks the minimum distance.

*   **TC-1.4.4:** **Tie-Breaking Rule (First Found)**
    *   *Input:* A synthetic signature equidistant (e.g., dist=2) from Archetype A and Archetype B.
    *   *Expected Output:* The Archetype appearing first in the definition/iteration order.
    *   *Goal:* Ensure deterministic behavior.

### Suite 3: Vector Evolution (`updateVector`)
*   **TC-1.4.5:** **Update towards Target 0 (Option A)**
    *   *Input:* Current=85, Choice='A' (Target=0).
    *   *Calc:* $85 + (0 - 85) \times 0.3 = 85 - 25.5 = 59.5$.
    *   *Expected Output:* 60 (Round to nearest integer).

*   **TC-1.4.6:** **Update towards Target 100 (Option B)**
    *   *Input:* Current=85, Choice='B' (Target=100).
    *   *Calc:* $85 + (100 - 85) \times 0.3 = 85 + 4.5 = 89.5$.
    *   *Expected Output:* 90 (Round to nearest integer).

*   **TC-1.4.7:** **Boundary Stability**
    *   *Input:* Current=0, Choice='A' (Target=0) -> Exp: 0.
    *   *Input:* Current=100, Choice='B' (Target=100) -> Exp: 100.
    *   *Input:* Current=50, Choice='A' -> $50 - 15 = 35$.

### Suite 4: Phase 2 Dimension Selection (`getTargetDimensions`)
*   **TC-1.4.8:** **Mandatory Dimensions Inclusion**
    *   *Input:* Any valid vector.
    *   *Expected Output:* Array containing 'STR', 'INF', 'ANC' + 2 others.

*   **TC-1.4.9:** **Ambiguity Selection (Distance from 50)**
    *   *Input:* Vector where 'POS'=55 (diff 5), 'TEM'=80 (diff 30), 'DEN'=20 (diff 30).
    *   *Logic:* 'POS' is closest to 50. It should be selected.
    *   *Expected Output:* Includes 'POS'.

*   **TC-1.4.10:** **Selection Tie-Breaking (Phase 1 Order)**
    *   *Context:* We need 2 "fuzzy" dimensions.
    *   *Input:* Vector where 'POS'=40 (diff 10), 'TEM'=60 (diff 10), 'DEN'=40 (diff 10). All others further away.
    *   *Logic:* All 3 are equidistant from 50.
    *   *Rule:* Select based on `PHASE_1_ORDER`: [POS, TEM, DEN, PRI, CAD, REG].
    *   *Expected Output:* 'POS' and 'TEM' (First two in order). 'DEN' is excluded.

## 3. Test Data Requirements
*   **Mock Vstyle:** `[25, 65, 85, 85, 30, 15, 20, 60, 60]` (Strategist Base).
*   **Mock Signatures:**
    *   Exact: "101100"
    *   Modified: "000000" (To test max distance logic).

## 4. Automation
*   Implement these tests in `lib/ice-protocol.spec.ts`.
*   Run via `npm run test` or `npx vitest`.
