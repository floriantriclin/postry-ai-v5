# Requirements Traceability Matrix

## Story: 1.5 - API de Génération de Questions ICE

### Coverage Summary

- **Total Requirements**: 12
- **Fully Covered**: 11 (92%)
- **Partially Covered**: 0 (0%)
- **Not Covered**: 1 (8%)

### Requirement Mappings

#### AC1: Endpoint POST /api/quiz/generate exists
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should call generateWithGemini for Phase 1"
  - Given: A POST request to /api/quiz/generate
  - When: Valid phase 1 payload is sent
  - Then: API returns 200 OK

#### AC2: Zod Request Validation
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should return 400 for invalid request body"
  - Given: A POST request with invalid 'phase' or missing 'topic'
  - When: Schema validation is performed
  - Then: API returns 400 Bad Request
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should return 400 for Phase 2 without context"
  - Given: Phase 2 requested without context
  - When: Zod validation runs
  - Then: API returns 400

#### AC3: Phase 1 Generation (6 Questions)
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should call generateWithGemini for Phase 1"
  - Given: Phase 1 is requested
  - When: API processes the request
  - Then: generateWithGemini is called with Phase 1 prompt and returns 200

#### AC4: Phase 2 Generation (5 Questions + Context)
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should call generateWithGemini for Phase 2"
  - Given: Phase 2 is requested with context
  - When: API processes the request
  - Then: generateWithGemini is called with Phase 2 prompt and returns 200

#### AC5: Zod Response Validation (DATA-001)
**Coverage: FULL**
- **Unit Test**: `lib/gemini.test.ts` :: "should throw error if Gemini returns data that fails Zod validation"
  - Given: Malformed Gemini response (e.g., invalid ID format)
  - When: QuizResponseSchema.parse is called
  - Then: Throws ZodError, triggering retry or error handling

#### SEC-001: Topic Sanitization
**Coverage: FULL**
- **Unit Test**: `lib/gemini.test.ts` :: "sanitizeTopic"
  - Given: A topic with HTML tags or prompt injection strings
  - When: sanitizeTopic is called
  - Then: Harmful content is removed and length is truncated
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should sanitize the topic"
  - Verifies the function is called during request processing.

#### SEC-002: API Key Security
**Coverage: FULL**
- **Unit Test**: `lib/gemini.test.ts` :: "should throw error if GEMINI_API_KEY is not defined"
  - Given: Missing environment variable
  - When: generateWithGemini is called
  - Then: Throws configuration error
- **Static Analysis**: `lib/gemini.ts` uses `process.env.GEMINI_API_KEY` and checks for its existence.

#### TECH-001: JSON Cleaning
**Coverage: FULL**
- **Unit Test**: `lib/gemini.test.ts` :: "cleanJsonResponse"
  - Given: Raw LLM output with markdown or text
  - When: cleanJsonResponse is called
  - Then: Valid JSON substring is extracted

#### TECH-001: Retry Strategy (3 Attempts)
**Coverage: FULL**
- **Unit Test**: `lib/gemini.test.ts` :: "should retry on failure and succeed"
  - Given: Network error on first attempt
  - When: generateWithGemini is called
  - Then: Retries and succeeds on second attempt
- **Unit Test**: `lib/gemini.test.ts` :: "should fail after maximum retries"
  - Verifies exhaustion of retry budget.

#### TECH-001: 502 Error Handling
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should return 502 if generateWithGemini fails"
  - Given: Gemini service fails after all retries
  - When: API processes the request
  - Then: Returns 502 Bad Gateway

#### PERF-001: Performance SLAs (Timeout)
**Coverage: FULL**
- **Integration Test**: `app/api/quiz/generate/route.test.ts` :: "should return 504 on timeout"
  - Given: Gemini takes longer than 15s (simulated via AbortError)
  - When: API receives abort signal
  - Then: Returns 504 Gateway Timeout

#### Observability: Structured Logs
**Coverage: NONE**
- **Gap**: No tests verify that errors are logged with appropriate context. `correlationId` is missing from implementation.
- **Risk**: Low - Basic console.error exists, but lacks the structure required for enterprise observability.

### Critical Gaps

1. **Observability (Structured Logging)**
   - Gap: Missing `correlationId` and lack of automated tests for logging.
   - Risk: Low - Not blocking for MVP but recommended for production.
   - Action: Implement a logging utility that supports correlation IDs and add vitest spies for logging.

### Test Design Recommendations

1. **Log Spying**: Use `vi.spyOn(console, 'error')` in tests to verify that critical errors (Gemini failures, validation errors) log the necessary metadata.
2. **Correlation ID**: Pass a `correlationId` from the request header down to the AI service for better traceability in production.

### Risk Assessment

- **High Risk**: None. All core functional and robustness requirements are covered.
- **Medium Risk**: Observability (8% of requirements) is the only remaining gap.
- **Low Risk**: Core functional paths, security, and robustness (retries/timeouts) are 100% covered by automated tests.
